-- HR 계정 접속


-- 1. DEPARTMENT_NAME의 오름차순 정렬 기준으로 전체 사원들의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID를 조회하시오.
-- 조인 DEPARTMNET_NAME 때문에, DEPARTMENTS 테이블 소속이고 나머지는 EMPLOYEES 테이블에 속해있어서
-- DEPARTMENT_ID 양쪽에 있어서 DEPARTMENTS나 EMPLOYEES에 있는거 아무거나 꺼내 쓰면 댐
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME -- E.DEPARTMENT_ID 도 가능
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_NAME ASC;

-- 타입이 섞여 있는경우의 오름차순 정렬
-- 문자 -> 숫자 -> 날짜 -> NULL

-- 2. DEPARTMENT_ID가 20인 사원중에서 전체 평균 연봉(SALARY) 이상을 받는 사원의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY를 조회하시오.
-- 전부다 EMPLOYEES 테이블에 있음 - 서브쿼리로풀어야됨(전체 평균 연봉)
-- 메인 쿼리 : SELECT 칼럼 FROM 테이블 WHERE 부서번호 = 20 AND 연봉 >= (전체평균연봉(서브쿼리))
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20
AND SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEES);--연봉이 전체평균연봉 이상이다 --집계함수 단위는 최소 SELECT ~ FROM~


-- 3. JOB_ID가 'IT_PROG'인 사원중에서 가장 높은 연봉(SALARY)을 받는 사원의 연봉보다 더 많은 연봉을 받는 사원들의 EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY를 조회하시오.
-- 서브쿼리 : 최대연봉
-- 메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE 연봉 > ( 직업 = 'IT'_PROG'의 최대 연봉)
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE SALARY >(SELECT MAX(SALARY) FROM EMPLOYEES WHERE JOB_ID =  'IT_PROG');

-- 4. EMPLOYEE_ID가 115인 사원과 동일한 JOB_ID와 DEPARTMENT_ID를 가진 사원의 EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID를 조회하시오.

-- 서브쿼리 : 사원번호가 115인 사원의 JOB_ID와 DEPARTMENT_ID 가져오기
-- 메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE (JOB_ID, DEPARTMENT_ID) = (사원번호가 115인 사원의 JOB_ID와 DEPARTMENT_ID 가져오기) ROW가 하나 나옴(단일행 서브쿼리) 사원번호(PK) 115
--(X) 메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE (JOB_ID, DEPARTMENT_ID) IN (사원번호가 115인 사원의 JOB_ID와 DEPARTMENT_ID 가져오기)(X) IN 다중행문법 답은 나옴

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE (JOB_ID, DEPARTMENT_ID) = (SELECT JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 115);

-- 5. LOCATION_ID가 1000~1500 사이인 국가들의 COUNTRY_ID, COUNTRY_NAME을 조회하시오.
-- 부모테이블 : PK를 가진 테이블 COUNTRYIES(COUNTRY_ID(PK))
-- 자식테이블 : FK를 가진 테이블 LOCATIONS(COUNTRY_ID(FK)))

-- 1) 조인
SELECT DISTINCT C.COUNTRY_ID, C.COUNTRY_NAME -- COUNTRY_ID 양쪽에 있어서 L.COUNTRY_ID도 가능 DISTINCT 중복제거 할 칼럼 앞에
FROM COUNTRIES C INNER JOIN LOCATIONS L
ON C.COUNTRY_ID = L.COUNTRY_ID
WHERE L.LOCATION_ID BETWEEN 1000 AND 1500;

-- 2) 서브쿼리
-- 서브쿼리 : LOCATION_ID가 1000~1500인 지역의 COUNTRY_ID 가져오기(다중행)
-- 메인쿼리 : SELECT 칼럼 FROM COUNTRIES WHERE COUNTRY_ID IN (서브쿼리) -- '='은 단일행 연산자
SELECT COUNTRY_ID, COUNTRY_NAME
FROM COUNTRIES
WHERE COUNTRY_ID IN (SELECT DISTINCT COUNTRY_ID FROM LOCATIONS WHERE LOCATION_ID BETWEEN 1000 AND 1500);

-- 6. MANAGER가 아닌 사원들의 EMPLOYEE_ID, FIRST_NAME을 조회하시오.
-- MANAGER가 아닌 사원 : EMPLOYEE_ID가 MANAGER_ID에 없는 사원
-- 서브쿼리 : MANAGER_ID의 중복 제거 결과(MANAGER의 번호 모아두기)
-- 메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE EMPLOYEE_ID IN (서브쿼리)
-- 서브쿼리의 결과가 NULL을 포함하면 메인쿼리가 동작하지 않는다.
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID 
--NOT IN(SELECT DISTINCT MANAGER_ID FROM EMPLOYEES); -- NULL이 들어가 결과가 메인쿼리 결과가 출력되지않음
NOT IN(SELECT DISTINCT MANAGER_ID FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL);

-- 7. 근무하는 CITY가 'Southlake'인 사원들의 EMPLOYEE_ID, FIRST_NAME를 조회하시오.
-- 관계
-- LOCATIONS 테이블에 CITY 칼럼, LOCATION_ID칼럼(PK) EMPLOYEES
-- DEPARTMENTS 테이블에 LOCATION_ID(FK), DEPARTMENT_ID(PK) DEPARTMENT
-- EMPLOYEES 테이블에 DEPARTMENT_ID(FK), EMPLOYEE_ID

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, L.CITY
FROM LOCATIONS L, DEPARTMENTS D, EMPLOYEES E
WHERE L.LOCATION_ID = D.LOCATION_ID
AND D.DEPARTMENT_ID = E.DEPARTMENT_ID
AND L.CITY = 'Southlake'; -- 대소문자 잘 지키기

-- 2) 서브쿼리



-- 8. 가장 많은 사원이 근무 중인 부서의 DEPARTMENT_ID와 근무 인원 수를 조회하시오.
-- 부서별 사원수 구하기 GROUP BY-> 가장 많은 사원이 근무중인 부서 찾기
-- 조건 : 근무중인 사원수 = 최대사원수
-- HAVING OR WHERE? -> HAVING,  COUNT랑 MAX 같은 집계함수를 사용한 조건은 HAVING절만 가능
SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) = (SELECT MAX(COUNT(*)) FROM EMPLOYEES GROUP BY DEPARTMENT_ID);

-- PARTITION BY를 활용

-- 9. 전체 사원 중 최대 연봉을 받는 사원의 EMPLOYEE_ID, FIRST_NAME, SALARY를 조회하시오.
-- ROWNUM
-- 인라인뷰 A : 가장 높은 연봉이 맨 위에 있는 테이블
-- 인라인뷰 B : 연봉순으로 정렬된 테이블에 행 번호(RN)를 부착시켜 둔 테이블
-- 최종결과 : 인라인뷰 B에서 행번호(RN)가 1인 행 조회
SELECT B.EMPLOYEE_ID, B.FIRST_NAME, B.SALARY
FROM (SELECT ROWNUM AS RN, A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY
        FROM (SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
                FROM EMPLOYEES
                ORDER BY SALARY DESC)A)B
WHERE B.RN = 1;

-- 10. 연봉 TOP 11 ~ 20 사원의 EMPLOYEE_ID, FIRST_NAME, SALARY를 조회하시오.

-- 인라인뷰 A : 연봉순으로 정렬된 뒤 행 번호(RN)가 부착된 테이블
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY
FROM (SELECT ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS RN, EMPLOYEE_ID, FIRST_NAME, SALARY
        FROM EMPLOYEES) A
WHERE A.RN BETWEEN 11 AND 20;